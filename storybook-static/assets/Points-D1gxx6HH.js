import{j as d}from"./jsx-runtime-CkxqCPlQ.js";const P=(s,t=[""])=>{const e={};for(const[i,n]of Object.entries(s)){if(n===void 0)continue;const r=Array.isArray(n)?n:[n],o=q(i);for(let l=0;l<r.length&&!(t.length<=l);l++)e["--"+t[l]+o]=r[l]}return e},U=(s,t="px")=>s!==void 0?typeof s=="string"?s:s+t:"none",v=(...s)=>s.filter(t=>t).join(" "),L=s=>s?{"--shadow":s.split(",").map(t=>`drop-shadow(${t})`).join(" ")}:{},q=s=>s.replace(/[A-Z]/g,t=>"-"+t.toLowerCase()),y=({objectBounding:s,components:{clipPath:t={}}={},id:e,...i})=>d.jsxs(d.Fragment,{children:[d.jsx("path",{id:e,...i}),d.jsx("clipPath",{id:e+"-clip",clipPathUnits:s?"objectBoundingBox":void 0,...t,...t,children:d.jsx("use",{href:"#"+e})})]});try{y.displayName="PathDefinition",y.__docgenInfo={description:`The Path definition defined a path with an ID. This ID will be used throughout the rendering process to references the path and clipPath

Typically this would be used inside a defs container.


it is important to note that the id provided will be reused to identify multiple components. For example this component creates both a path and clip path using the provided path commands. the id for the clip path is <id>-clip. In the future masks and feEffects may be added`,displayName:"PathDefinition",props:{id:{defaultValue:null,description:"A path definition must be provided a unique id. This is used to reference the path.",name:"id",required:!1,type:{name:"string"}},objectBounding:{defaultValue:null,description:"If object bounding is pass through the all geometries will be normalized. This is benefitial if using the same path to clip an html element.",name:"objectBounding",required:!1,type:{name:"boolean | undefined"}},components:{defaultValue:null,description:"Components will be a record of prop overrides available.",name:"components",required:!1,type:{name:"PathDefinitionComponents | undefined"}}}}}catch{}const f=({geometry:s,objectBounding:t,...e})=>d.jsx(y,{d:""+(t?s.normalize():s),objectBounding:t,...e}),F=f;try{f.displayName="GeometryDefinition",f.__docgenInfo={description:"The GeometryDefinition is a specialized PathDefinition Component that uses the Points class to render a polygon using points or generator methods.",displayName:"GeometryDefinition",props:{geometry:{defaultValue:null,description:"The **Points** class that is used to generate the path commands.",name:"geometry",required:!0,type:{name:"Points"}},id:{defaultValue:null,description:"A path definition must be provided a unique id. This is used to reference the path.",name:"id",required:!1,type:{name:"string"}},objectBounding:{defaultValue:null,description:"If object bounding is pass through the all geometries will be normalized. This is benefitial if using the same path to clip an html element.",name:"objectBounding",required:!1,type:{name:"boolean | undefined"}},components:{defaultValue:null,description:"Components will be a record of prop overrides available.",name:"components",required:!1,type:{name:"PathDefinitionComponents | undefined"}}}}}catch{}const m=({className:s,defs:t,children:e,...i})=>d.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",className:v(s,"shapely-svg-canvas"),preserveAspectRatio:"none",...i,children:[t&&d.jsx("defs",{children:t}),e]}),O=m;try{m.displayName="SVGCanvas",m.__docgenInfo={description:`The SVGCanvas is an SVG element that does not preserveAspectRatio. 

The reason for this being it expects its content to preserve the aspect ratio. this allows for a cleaner implementation of objectBoundingUnits.`,displayName:"SVGCanvas",props:{defs:{defaultValue:null,description:"Simply an alias to an internal &lt;defs&gt;",name:"defs",required:!1,type:{name:"ReactNode"}}}}}catch{}const g=({className:s,src:t,fill:e,stroke:i,strokeWidth:n,clipped:r,style:o={},...l})=>d.jsx("use",{className:v(s,"shapely-geometry-ref"),href:t,style:{clipPath:r&&t?`url(${t}-clip)`:void 0,fill:e,stroke:i,strokeWidth:n,...o},...l}),Q=g;try{g.displayName="GeometryRef",g.__docgenInfo={description:"",displayName:"GeometryRef",props:{src:{defaultValue:null,description:"Unlike href src is required and will populate both href as well as clip path",name:"src",required:!1,type:{name:"string | undefined"}},clipped:{defaultValue:null,description:"Clipping a shape is not always necessary. but if you are using a clipped definition this can be provided to the ref to instruct it to populate the clip path using shapelys clipping convention.",name:"clipped",required:!1,type:{name:"boolean | undefined"}}}}}catch{}const h=(s,t)=>{if(!t)return Math.round(s);const e=10**t;return Math.round(Math.round(s*e))/e},D=s=>s*Math.PI/180;class a extends Array{constructor(t,e){super(t,e)}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get control(){return new a(this.x,this.y)}cp(){return new a(this.x,this.y)}ray(t,e){return new a(e*Math.sin(t),e*Math.cos(t)).adding(this)}rayDeg(t,e){return this.ray(D(t),e)}add([t,e]){return new a(this.x+t,this.y+e)}adding([t,e]){return this.x+=t,this.y+=e,this}addScalar(t){return new a(this.x+t,this.y+t)}subtract([t,e]){return new a(this.x-t,this.y-e)}subtracting([t,e]){return this.x-=t,this.y-=e,this}subtractScalar(t){return new a(this.x-t,this.y-t)}multiply([t,e]){return new a(this.x*t,this.y*e)}multiplying([t,e]){return this.x*=t,this.y*=e,this}multiplyScalar(t){return new a(this.x*t,this.y*t)}divide([t,e]){return new a(this.x/t,this.y/e)}dividing([t,e]){return this.x/=t,this.y/=e,this}divideScalar(t){return new a(this.x/t,this.y/t)}min([t,e]){return new a(Math.min(this.x,t),Math.min(this.y,e))}max([t,e]){return new a(Math.max(this.x,t),Math.max(this.y,e))}precision(t){return this.x=h(this.x,t),this.y=h(this.y,t),this}to([t,e]){const i=t-this.x,n=e-this.y;return{angle:Math.atan2(i,n),distance:Math.sqrt(i**2+n**2)}}from([t,e]){const i=this.x-t,n=this.y-e;return{angle:Math.atan2(i,n),distance:Math.sqrt(i**2+n**2)}}rotateAround(t,e){const{angle:i,distance:n}=this.from(t);return this.ray(i+e,n)}simplify(){const t=(n,r)=>r===0?n:t(r,n%r),e=t(this.x,this.y);return this.cp().divideScalar(e)}toString(){return a.toString(this)}toArray(){return[this.x,this.y]}static get zero(){return new a(0,0)}static px(t,e){return new a(t,e)}static toString([t,e],i=5){return`${h(t,i)}, ${h(e,i)}`}}class c extends a{get sx(){return this[2]}set sx(t){this[2]=t}get sy(){return this[3]}set sy(t){this[3]=t}get ex(){return this[4]}set ex(t){this[4]=t}get ey(){return this[5]}set ey(t){this[5]=t}constructor([t,e],[i,n],[r,o]){super(i,n),this.push(t,e,r,o)}add([t,e]){return new c([this.sx+t,this.sy+e],[this.x+t,this.y+e],[this.ex+t,this.ey+e])}adding([t,e]){return this.x+=t,this.sx+=t,this.ex+=t,this.y+=e,this.sy+=e,this.ey+=e,this}addScalar(t){return this.add([t,t])}subtract([t,e]){return new c([this.sx-t,this.sy-e],[this.x-t,this.y-e],[this.ex-t,this.ey-e])}subtracting([t,e]){return this.x-=t,this.sx-=t,this.ex-=t,this.y-=e,this.sy-=e,this.ey-=e,this}subtractScalar(t){return this.subtract([t,t])}multiply([t,e]){return new c([this.sx*t,this.sy*e],[this.x*t,this.y*e],[this.ex*t,this.ey*e])}multiplying([t,e]){return this.x*=t,this.sx*=t,this.ex*=t,this.y*=e,this.sy*=e,this.ey*=e,this}multiplyScalar(t){return new c([this.sx*t,this.sy*t],[this.x*t,this.y*t],[this.ex*t,this.ey*t])}divide([t,e]){return new c([this.sx/t,this.sy/e],[this.x/t,this.y/e],[this.ex/t,this.ey/e])}dividing([t,e]){return this.x/=t,this.sx/=t,this.ex/=t,this.y/=e,this.sy/=e,this.ey/=e,this}divideScalar(t){return this.divide([t,t])}rotateAround(t,e){return new c(a.px(this.sx,this.sy).rotateAround(t,e),a.px(this.x,this.y).rotateAround(t,e),a.px(this.ex,this.ey).rotateAround(t,e))}precision(t){return this.x=h(this.x,t),this.y=h(this.y,t),this.sx=h(this.sx,t),this.sy=h(this.sy,t),this.ex=h(this.ex,t),this.ey=h(this.ey,t),this}toString(){return`${a.toString([this.sx,this.sy])} Q ${a.toString([this.x,this.y])} ${a.toString([this.ex,this.ey])}`}toArray(){return[this.x,this.y,this.sx,this.sy,this.ex,this.ey]}}const z=s=>function*(){if(s.length%2)throw new Error("Invalid buffer size");for(let t=0;t<s.length;t+=2)yield new a(s[t],s[t+1])},I=(s,t=0,e=a.zero,i=50)=>function*(){if(s<2)throw new Error("At least two stop must be requested");s<3&&console.warn("The smallest polygon typically has 3 sides");const n=Math.PI*2/s;for(let r=0;r<s;r+=Math.min(s-r,1))yield e.ray(n*r+t,i)},b=(s,t)=>function*(){for(const e of s())yield e.add(t)},C=(s,t,e)=>function*(){for(const i of s())yield i.rotateAround(e,t)},T=(s,t)=>function*(){for(const e of s())yield e.multiply(t)},N=(s,t)=>function*(){const e=s();let i=e.next();if(i.done)return;let n=i.value;if(i=e.next(),i.done){yield n;return}let r=i.value;const o=n,l=r;let u=1;for(const[j,$]of e){const w=new a(j,$),[M,V]=p(r,n,w,t,u);u++,yield new c(M,r,V),n=r,r=w}const[S,_]=p(r,n,o,t,u);yield new c(S,r,_);const[A,G]=p(o,r,l,t,0);yield new c(A,o,G)},p=(s,t,e,i,n)=>{const r=Array.isArray(i)?i[n]??0:i,{angle:o}=s.to(t),{angle:l}=s.to(e);return[s.ray(o,r),s.ray(l,r)]},B=(s,[t,e])=>function*(){const i=b(s,t.multiplyScalar(-1))();for(const n of i)yield n.divide(e)},k=(s,...t)=>s.reduce((e,i,n)=>n>=t.length||t[n]===void 0?e+i:t[n]instanceof a||t[n]instanceof c?e+i+t[n]:Array.isArray(t[n])?e+i+t[n].slice(0,2).map(r=>h(r,5)).join(", "):e+i+(typeof t[n]=="string"?t[n]:h(t[n],5)),"");class x{constructor(t,e=!1){this.center=a.zero,this.generator=Array.isArray(t)?z(t):t,this.noClose=e}get viewBox(){return this._vw||this.measure(),this._vw}get aspectRatio(){return this._ar||this.measure(),this._ar}get viewInfo(){return(!this._vw||!this._ar)&&this.measure(),[this._ar,this._vw]}get bounds(){return this._bounds||this.measure(),this._bounds}translate(t){return this.center.adding(t),this.applyGenerator(b(this.generator,t))}rotate(t){return this.applyGenerator(C(this.generator,t,this.center))}scale(t){return this.center.multiplying(t),this.applyGenerator(T(this.generator,t))}normalize(t=this.measure()){return this.center.subtracting(t[0]),this.applyGenerator(B(this.generator,t))}round(t){return this.applyGenerator(N(this.generator,t))}scaleByScalar(t){const e=this.generator;return this.applyGenerator(function*(){for(const n of e())yield n.multiplyScalar(t)})}measure(){let t=this.center,e=this.center;for(const o of this.generator())t=t.min(o),e=e.max(o);const i=e.subtract(t),[n,r]=i.simplify();return this._vw=`${t[0]} ${t[1]} ${i[0]} ${i[1]}`,this._ar=`${n} / ${r}`,this._bounds=[t,i,e],this._bounds}precision(t){const e=this.generator;return this.applyGenerator(function*(){for(const n of e())yield n.precision(t)})}invalidateDimensions(){return this._ar=void 0,this._vw=void 0,this._bounds=void 0,this}applyGenerator(t){return this.generator=t,this.invalidateDimensions()}shouldClose(t){return this.noClose=!t,this}toArray(){const t=[];for(const e of this.generator())t.push(e);return t}toString(){let t="";for(const e of this.generator())t+=k`${t?" L":"M"} ${e}`;return t+(this.noClose?"":"z")}static fromCircle(t,e=0,i=a.zero){return new x(I(t,e,i))}}const R=x;export{F as G,R as P,O as S,Q as a,L as b,v as c,I as f,U as s,D as t,P as v};
