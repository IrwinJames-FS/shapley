import{j as e}from"./jsx-runtime-CkxqCPlQ.js";import{useMDXComponents as n}from"./index-BrnU7xv7.js";import{ae as o}from"./index-DryY4Ina.js";import"./index-DJO9vBfz.js";import"./iframe-DulR_S7U.js";import"../sb-preview/runtime.js";import"./index-DLC2J04D.js";import"./index-D-8MO0q_.js";import"./index-0wbOH00J.js";import"./index-DrFu-skq.js";function s(r){const t={h2:"h2",h3:"h3",hr:"hr",p:"p",strong:"strong",...n(),...r.components};return e.jsxs(e.Fragment,{children:[e.jsx(o,{title:"geometry/types"}),`
`,e.jsxs("div",{className:"doc-block",style:{marginLeft:"0rem"},children:[e.jsx("span",{className:"declaration-text",children:"type"}),e.jsx(t.h2,{id:"vector",children:"Vector"}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Source"}),": ",e.jsx("a",{href:"/?path=/docs/geometry-types-source--docs#11",children:"geometry/types.ts(ln: 11)"})]}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Signature"}),": [",e.jsx("span",{className:"declaration-text",children:"number"}),", ",e.jsx("span",{className:"declaration-text",children:"number"}),", ",e.jsx("span",{className:"declaration-text",children:"number"}),"]"]}),e.jsx(t.p,{children:"The vector type is used to declare the 2 dimensional point along with an angle to use as a trajectory."}),e.jsx(t.hr,{})]}),`
`,e.jsxs("div",{className:"doc-block",style:{marginLeft:"2rem"},children:[e.jsx("span",{className:"declaration-text",children:"property"}),e.jsx(t.h3,{id:"symbolunscopables",children:"[Symbol.unscopables]"}),e.jsx(t.hr,{})]}),`
`,e.jsxs("div",{className:"doc-block",style:{marginLeft:"0rem"},children:[e.jsx("span",{className:"declaration-text",children:"type"}),e.jsx(t.h2,{id:"rect",children:"Rect"}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Source"}),": ",e.jsx("a",{href:"/?path=/docs/geometry-types-source--docs#16",children:"geometry/types.ts(ln: 16)"})]}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Signature"}),": [",e.jsx("a",{href:"/?path=/docs/geometry-Point--docs#Point",children:"Point"}),", ",e.jsx("a",{href:"/?path=/docs/geometry-Point--docs#Point",children:"Point"}),", ",e.jsx("a",{href:"/?path=/docs/geometry-Point--docs#Point",children:"Point"}),"]"]}),e.jsx(t.p,{children:"This is a min max rect where the first two numbers are the min coordinate and the last two numbers are the max coordinates in the rect."}),e.jsx(t.hr,{})]}),`
`,e.jsxs("div",{className:"doc-block",style:{marginLeft:"0rem"},children:[e.jsx("span",{className:"declaration-text",children:"type"}),e.jsx(t.h2,{id:"vertexgenerator",children:"VertexGenerator"}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Source"}),": ",e.jsx("a",{href:"/?path=/docs/geometry-types-source--docs#23",children:"geometry/types.ts(ln: 23)"})]}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Signature"}),": ()=>",e.jsx("span",{className:"declaration-text",children:"Generator"}),"<",e.jsx("a",{href:"/?path=/docs/geometry-Point--docs#Point",children:"Point"})," | ",e.jsx("a",{href:"/?path=/docs/geometry-RoundedCorner--docs#RoundedCorner",children:"RoundedCorner"}),",",e.jsx("span",{className:"declaration-text",children:"any"}),",",e.jsx("span",{className:"declaration-text",children:"unknown"}),">"]}),e.jsx(t.p,{children:"The vertex generator is a method that returns a Generator method or an IteratableIterator."}),e.jsx(t.p,{children:"The generator it returns should always return a Point or RoundedCorner method."}),e.jsx(t.hr,{})]}),`
`,e.jsxs("div",{className:"doc-block",style:{marginLeft:"0rem"},children:[e.jsx("span",{className:"declaration-text",children:"type"}),e.jsx(t.h2,{id:"supportedpointmathtypes",children:"SupportedPointMathTypes"}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Source"}),": ",e.jsx("a",{href:"/?path=/docs/geometry-types-source--docs#28",children:"geometry/types.ts(ln: 28)"})]}),e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Signature"}),": ",e.jsx("a",{href:"/?path=/docs/geometry-Point--docs#Point",children:"Point"})," | [",e.jsx("span",{className:"declaration-text",children:"number"}),", ",e.jsx("span",{className:"declaration-text",children:"number"}),"]"]}),e.jsx(t.p,{children:"Really I just need the numeric values provided by the additional points all the math will be relative to the point the function is being called from. therefore I can simplify the process by not requiring a point be provided. this will reduce necessary new calls and Point instances."}),e.jsx(t.hr,{})]})]})}function u(r={}){const{wrapper:t}={...n(),...r.components};return t?e.jsx(t,{...r,children:e.jsx(s,{...r})}):s(r)}export{u as default};
