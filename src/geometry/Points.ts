import { bufferIterator, fromCircle, normalize, rotate, rounded, scale, translate } from "./iterators";
import { $d } from "./ngon";
import Point from "./Point";
import { round as roundNumber } from './arithmetic';
import { Rect, VertexGenerator } from "./types";
import RoundedCorner from "./RoundedCorner";


/**
 * A Vector generator is a reusable generator method.
 * 
 * Geometries and react components require reusable Generators. 
 * 
 * This allows for measuring and rerendinging appropriately.
 */

/**
 * Points uses generator methods to append actions to an iteration reducing the number of times a vertex list needs to be iterated.
 */
class Points {

	//this is a method  to reconst

	/**
	 * The generator property is a reusable Generator which at time of render will iterate and produce the desired points. 
	 * As the Points are mutated this method will be updated chaining the mutations. 
	 */
	generator: VertexGenerator;
	center: Point = Point.zero;

	/**
	 * By default Shapes generated by the Points class are closed using z. However in some uses cases (such as animating the stroke) a path may not be closed 
	 */
	noClose: boolean

	/** @private */
	private _vw?: string
	/** @private */
	private _ar?: string
	/** @private */
	private _bounds?: Rect

	/**
	 * The first point should be either a VertexGenerator (such as the fromCircle Iterator or the pointsBuffer iterator) or an **Array**&lt;*number*&gt;.
	 * 
	 * @param points 
	 * @param noClose 
	 */
	constructor(points: number[] | VertexGenerator, noClose: boolean = false) {
		this.generator = Array.isArray(points) ? bufferIterator(points): (points as VertexGenerator);
		this.noClose = noClose;
	}

	/**
	 * The view box generates an svg view box based on the indices of the path. It is recommended normalized paths are used. especially in Grid components (This allows the path units to be clipPathUnits for clipping of each cell)
	 * 
	 * Calling this property will trigger an iteration of points if the shape has not been measured since its last Mutation. That being said subsequent calls will not trigger additional iterations through the points.
	 */
	get viewBox() {
		if(!this._vw)this.measure()
		return this._vw;
	}

	/**
	 * Because the SVG needs to occupy all of the space without applying its own scaling preserveAspectRatio is typically set to none. As such the parent element of the SVG is responsible for maintaining the aspect ratio. 
	 * If you are using Geometric, Polymetric or SVG references and manually representing a shape this property is a convenient way to get the css aspect ratio 
	 * 
	 * Calling this property will trigger an iteration of points if the shape has not been measured since its last Mutation. That being said subsequent calls will not trigger additional iterations through the points.
	 */
	get aspectRatio(){
		if(!this._ar) this.measure();
		return this._ar!;
	}

	/**
	 * Returns a tuple of the aspectRatio and View box. 
	 * 
	 * Calling this property will trigger an iteration of points if the shape has not been measured since its last Mutation. That being said subsequent calls will not trigger additional iterations through the points.
	 * @returns {[string, string]} - [Aspect Ratio, ViewBox]
	 */
	get viewInfo():[string, string]{
		if(!this._vw || !this._ar) this.measure();
		return [this._ar!, this._vw!]
	}

	/**
	 * Returns the size of the shape. 
	 * 
	 * Calling this property will trigger an iteration of points if the shape has not been measured since its last Mutation. That being said subsequent calls will not trigger additional iterations through the points.
	 * 
	 * If you want to force a method to update its bounds use the **measure()** method.
	 */
	get bounds():Rect{
		if(!this._bounds) this.measure();
		return this._bounds!;
	}

	/**
	 * Translate all points by a new position. This is effectively adding the new point to the center. 
	 * @param point 
	 * @returns 
	 */
	public translate(point:Point):Points {
		this.center.adding(point);
		return this.applyGenerator(translate(this.generator, point));
	}

	/**
	 * Rotates the points around a point by a specified radian
	 * @param angle 
	 * @param point - The point to rotate around assumes 0,0 if no point is provided
	 */
	public rotate(angle: number){
		return this.applyGenerator(rotate(this.generator, angle, this.center));
	}

	/**
	 * Scales the point by two a scale Factor Point
	 * @param scaleFactor 
	 * @returns 
	 */
	public scale(scaleFactor: Point){
		this.center.multiplying(scaleFactor);
		return this.applyGenerator(scale(this.generator, scaleFactor));
	}

	/**
	 * Converts the geometry to a series of points that exists between 0-1 where 0 is the smallest value in both the height and width. and 1 being the the largest value. This causes the geometry to no longer have a valid aspect ratio.
	 * 
	 * If you wish to preserve the original aspect ratio prior to this mutation it is recommended you cache the aspect Ratio prior to normalizing
	 * 
	 * **example:**
	 * take the triangle described by points 0,0, 1,1, -1,1. 
	 * This triangle is 2x1 in size
	 * once normalized it will be described as 0.5, 0, 1, 1, 0,0
	 * Its bounds being 1x1. however using objectBoundingUnits these values can applied to non square components. (kinda like percentages)
	 * For this shape to be displayed properly the shape needs to be in a component with the appropriate aspect ratio.
	 * @param bounds 
	 * @returns 
	 */
	public normalize(bounds: Rect = this.measure()){
		this.center.subtracting(bounds[0]);
		return this.applyGenerator(normalize(this.generator, bounds))
	}

	/**
	 * Rounds each corner. This effectively multiplies the number of points by three. A side effect of this is the point order will be shifted forward by two.
	 * 
	 * The corner radius value can be a static number or an array of values. If an array is provided and there is not a value for a point then the corner radius will be assumed to be 0.
	 * 
	 * If you are rounding and unrounding points the shift of point order will be imporatnt to keep in mind if providing corner radius for each corner.
	 * @param cornerRadius 
	 */
	public round(cornerRadius: number | number[]){
		return this.applyGenerator(rounded(this.generator, cornerRadius))
	}

	/**
	 * Scale by a single scale factor 
	 * @param scalar 
	 * @returns 
	 */
	public scaleByScalar(scalar: number){
		const gen = this.generator;
		return this.applyGenerator(function* rotator(){
			for(const p of gen()) yield p.multiplyScalar(scalar);
		});
	}


	/**
	 * Measure the current generator
	 * @returns 
	 */
	public measure():Rect{
		let min = this.center;
		let max = this.center;
		for(const p of this.generator()){
			min = min.min(p);
			max = max.max(p);
		}
		const size = max.subtract(min);
		const [w, h] = size;
		this._vw = `${min[0]} ${min[1]} ${size[0]} ${size[1]}`;
		this._ar = w > h ? `${roundNumber(w/h, 3)} / 1`:`${roundNumber(h/w, 3)} / 1`;
		this._bounds = [min, size, max];
		return this._bounds!;
	}

	public precision(prec: number){
		const gen = this.generator;
		return this.applyGenerator(function* Precision(){
			for(const p of gen()) yield p.precision(prec);
		})
	}

	public invalidateDimensions(){
		this._ar = undefined;
		this._vw = undefined;
		this._bounds = undefined;
		return this;
	}
	public applyGenerator(gen: VertexGenerator) {
		this.generator = gen;
		return this.invalidateDimensions();
	}

	public shouldClose(close: boolean){
		this.noClose = !close;
		return this;
	}
	/**
	 * Converts the shape to an array of points or Rounded Corners. 
	 * @returns 
	 */
	public toArray(){
		const array: (Point | RoundedCorner)[] = [];
		for(const point of this.generator()){
			array.push(point);
		}
		return array;
	}
	/**
	 * Representing points as a string will result in the path commands being generated.
	 * @returns 
	 */
	public toString(){
		let d = '';
		for(const p of this.generator()){
			const c = d ? ' L':'M';
			d += $d`${c} ${p}`;
		}
		return d+(this.noClose ? '':'z');
	}

	
	//Static methods

	/**
	 * Generates points by picking points around a circle.
	 * @param stops 
	 * @param rotation 
	 */
	public static fromCircle(stops: number, rotation: number=0, center: Point=Point.zero){
		return new Points(fromCircle(stops, rotation, center));
	}
};

export default Points