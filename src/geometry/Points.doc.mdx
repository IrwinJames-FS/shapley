import { Meta } from '@storybook/blocks';

<Meta title="src/geometry/Points" />

## Points
`src/geometry/Points`

**AST Node Type:** *ClassDeclaration*

#### JSDoc annotations:

A Vector generator is a reusable generator method.

Geometries and react components require reusable Generators.

This allows for measuring and rerendinging appropriately.


Points uses generator methods to append actions to an iteration reducing the number of times a vertex list needs to be iterated.

```bash

```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## translate
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Translate all points by a new position. This is effectively adding the new point to the center.

```bash
@param point

@returns
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## rotate
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Rotates the points around a point by a specified radian

```bash
@param angle

@param point - The point to rotate around assumes 0,0 if no point is provided
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## scale
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Scales the point by two a scale Factor Point

```bash
@param scaleFactor

@returns
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## round
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Rounds each corner. This effectively multiplies the number of points by three. A side effect of this is the point order will be shifted forward by two.

The corner radius value can be a static number or an array of values. If an array is provided and there is not a value for a point then the corner radius will be assumed to be 0.

If you are rounding and unrounding points the shift of point order will be imporatnt to keep in mind if providing corner radius for each corner.

```bash
@param cornerRadius
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## scaleByScalar
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Scale by a single scale factor

```bash
@param scalar

@returns
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## measure
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Measure the current generator

```bash
@returns
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## toString
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Representing points as a string will result in the path commands being generated.

```bash
@returns
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

## fromCircle
`src/geometry/Points`

**AST Node Type:** *MethodDeclaration*

#### JSDoc annotations:

Generates points by picking points around a circle.

```bash
@param stops

@param rotation
```

#### Code:

```ts
class Points {
    generator: VertexGenerator;
    center: Point = Point.zero;
    constructor(points: number[] | VertexGenerator) {
        this.generator = Array.isArray(points) ? bufferIterator(points) : (points as VertexGenerator);
    }
    get viewBox() {
        const [min, size] = this.measure();
        return $d `${min} ${size}`;
    }
    translate(point: Point): Points {
        this.center.adding(point);
        this.generator = translate(this.generator, point);
        return this;
    }
    rotate(angle: number) {
        this.generator = rotate(this.generator, angle, this.center);
        return this;
    }
    scale(scaleFactor: Point) {
        this.center.multiplying(scaleFactor);
        this.generator = scale(this.generator, scaleFactor);
        return this;
    }
    round(cornerRadius: number | number[]) {
        this.generator = round(this.generator, cornerRadius);
        return this;
    }
    public scaleByScalar(scalar: number) {
        const gen = this.generator;
        function* rotator() {
            for (const p of gen())
                yield p.multiplyScalar(scalar);
        }
        this.generator = rotator;
        return this;
    }
    measure() {
        let min = this.center;
        let max = this.center;
        for (const p of this.generator()) {
            min = min.min(p);
            max = max.max(p);
        }
        return [min, max.subtract(min), max];
    }
    toString() {
        let d = '';
        for (const p of this.generator()) {
            const c = d ? ' L' : 'M';
            d += $d `${c} ${p}`;
        }
        return d + 'z';
    }
    public static fromCircle(stops: number, rotation: number = 0, center: Point = Point.zero) {
        return new Points(fromCircle(stops, rotation, center));
    }
}

```

